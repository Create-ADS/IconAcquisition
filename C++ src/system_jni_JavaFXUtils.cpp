#include "systemIcon.h"

void DrawPng(HICON hIcon,const char* outputFilePath, double scale)
{
    HDC hdc = GetDC(NULL);
    scale = GetDeviceCaps(hdc, LOGPIXELSX) / 96.0;
    ReleaseDC(NULL, hdc);
    if (GetLastError() != 0)
    {
        printf("init Error: %d\n", GetLastError());
    }
    ICONINFO iconInfo;
    GetIconInfo(hIcon, &iconInfo);
    if (GetLastError() != 0)
    {
        printf("GetIconInfo Error: %d\n", GetLastError());
    }
    int iconWidth = iconInfo.xHotspot * 2;
    int iconHeight = iconInfo.yHotspot * 2;
    HDC hMemDC = CreateCompatibleDC(NULL);
    if (GetLastError() != 0)
    {
        printf("CreateCompatibleDC Error: %d\n", GetLastError());
    }
    HBITMAP hMemBitmap = CreateCompatibleBitmap(hdc, iconWidth, iconHeight);
    if (GetLastError() != 0)
    {
        printf("CreateCompatibleBitmap Error: %d\n", GetLastError());
    }
    SelectObject(hMemDC, hMemBitmap);
    if (GetLastError() != 0)
    {
        printf("SelectObject Error: %d\n", GetLastError());
    }
    DrawIconEx(hMemDC, 0, 0, hIcon, iconWidth * scale, iconHeight * scale, 0, NULL, DI_NORMAL);
    if (GetLastError() != 0)
    {
        printf("DrawIconEx Error: %d\n", GetLastError());
    }
    CLSID pngClsid;
    GetEncoderClsid(L"image/png", &pngClsid);
    Gdiplus::Bitmap bitmap(hMemBitmap, NULL);
    bitmap.Save(CharToWchar(outputFilePath), &pngClsid, NULL);
    if (GetLastError() != 0)
    {
        printf("bitmap.Save Error: %d\n", GetLastError());
    }
    DeleteObject(hMemBitmap);
    DeleteDC(hMemDC);
    DeleteObject(hIcon);
}

/**
 * @brief 获取解码器的CLSID
 * @param format 解码器格式
 * @param pClsid CLSID
 * @return 0成功，-1失败
*/
int GetEncoderClsid(const WCHAR* format, CLSID* pClsid)
{
	UINT num = 0, size = 0;

	Gdiplus::GetImageEncodersSize(&num, &size);
	if (size == 0)
		return -1;  // Failure

	Gdiplus::ImageCodecInfo* pImageCodecInfo = (Gdiplus::ImageCodecInfo*)(malloc(size));

	Gdiplus::GetImageEncoders(num, size, pImageCodecInfo);
	bool found = false;
	for (UINT ix = 0; !found && ix < num; ++ix)
	{
		if (_wcsicmp(pImageCodecInfo[ix].MimeType, format) == 0)
		{
			*pClsid = pImageCodecInfo[ix].Clsid;
			found = true;
			break;
		}
	}

	free(pImageCodecInfo);
	return found;
}


/**
 * @brief const char* 转换为 TCHAR*
 * @param str const char*
 * @return TCHAR*
*/
TCHAR* CharToTchar(const char* str)
{
	int len = MultiByteToWideChar(CP_ACP, 0, str, -1, NULL, 0);
	TCHAR* p = new TCHAR[len + 1];
	memset(p, 0, len + 1);
	MultiByteToWideChar(CP_ACP, 0, str, -1, p, len);
	return p;
}

/**
* const char* 转 WCHAR*
*/
WCHAR* CharToWchar(const char* str)
{
	int len = MultiByteToWideChar(CP_ACP, 0, str, -1, NULL, 0);
	WCHAR* p = new WCHAR[len + 1];
	memset(p, 0, len + 1);
	MultiByteToWideChar(CP_ACP, 0, str, -1, p, len);
	return p;
}

/**
 * const char* 转 LPCWSTR
*/
LPCWSTR CharToLPCWSTR(const char* str)
{
    int len = MultiByteToWideChar(CP_ACP, 0, str, -1, NULL, 0);
    WCHAR* p = new WCHAR[len + 1];
    memset(p, 0, len + 1);
    MultiByteToWideChar(CP_ACP, 0, str, -1, p, len);
    return p;
}

int main()
{
    SHFILEINFO shFileInfo = { 0 };
	BOOL ret;
	CoInitialize(NULL);
    ret = SHGetFileInfo(CharToLPCWSTR("C:\\Users\\adm\\Desktop\\iconsext.exe"), 0, &shFileInfo, sizeof(shFileInfo), SHGFI_ICON | SHGFI_SYSICONINDEX);
    if (!ret || shFileInfo.hIcon == NULL || shFileInfo.hIcon == INVALID_HANDLE_VALUE)
	{
		CoUninitialize();
		printf("SHGetFileInfo Error: %d\n", GetLastError());
        return -1;
	}
    Gdiplus::GdiplusStartupInput gdiplusStartupInput;
	ULONG_PTR gdiplusToken;
	GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL);
    DrawPng(shFileInfo.hIcon, "E:\\Run\\test.png", 1.0);
    if (GetLastError() != 0)
    {
        printf("DrawPng Error: %d\n", GetLastError());
    }

    Gdiplus::GdiplusShutdown(gdiplusToken);
	DestroyIcon(shFileInfo.hIcon);
	CoUninitialize();
}
